안드로이드 스튜디오에서 **복사해서 바로 실행**할 수 있도록 `OkHttp` 기반의 완성된 코드를 짜드렸습니다. 이 코드는 헤더 중복 문제를 완벽히 방지하며, 서버가 보내는 상세 에러 메시지를 로그캣에서 바로 확인할 수 있게 설계되었습니다.

---

### 1. 라이브러리 설정 (`build.gradle.kts`)

먼저 `app` 수준의 `build.gradle.kts` 파일에 아래 의존성을 추가하고 **Sync Now**를 눌러주세요.

```kotlin
dependencies {
    // OkHttp 핵심 라이브러리
    implementation("com.squareup.okhttp3:okhttp:4.12.0")
    // 로그 확인을 위한 인터셉터 (디버깅 필수)
    implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")
}

```

---

### 2. 인터넷 권한 (`AndroidManifest.xml`)

`<application>` 태그 위쪽에 인터넷 권한이 있는지 꼭 확인하세요.

```xml
<uses-permission android:name="android.permission.INTERNET" />

```

---

### 3. 전체 소스 코드 (`MainActivity.kt`)

이 코드는 버튼을 누르면 API를 호출하고, 결과를 로그캣(Logcat)과 화면에 보여줍니다.

```kotlin
import android.os.Bundle
import android.util.Log
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.logging.HttpLoggingInterceptor
import java.io.IOException

class MainActivity : AppCompatActivity() {

    // 1. OkHttpClient 설정 (로그 인터셉터 포함)
    private val client: OkHttpClient by lazy {
        val logging = HttpLoggingInterceptor { message ->
            Log.d("OKHTTP_LOG", message) // 로그캣에서 'OKHTTP_LOG'로 필터링하세요
        }.apply {
            level = HttpLoggingInterceptor.Level.BODY
        }

        OkHttpClient.Builder()
            .addInterceptor(logging)
            .followRedirects(true)
            .build()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // 테스트를 위한 간단한 레이아웃 생성
        val layout = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            setPadding(50, 50, 50, 50)
        }
        val btn = Button(this).apply { text = "API 호출 테스트" }
        val tv = TextView(this).apply { text = "결과가 여기 표시됩니다." }
        layout.addView(btn)
        layout.addView(tv)
        setContentView(layout)

        btn.setOnClickListener {
            tv.text = "호출 중..."
            callSmartThingsApi { result ->
                runOnUiThread { tv.text = result }
            }
        }
    }

    private fun callSmartThingsApi(callback: (String) -> Unit) {
        // [수정 포인트 1] 실제 URL 확인
        val url = "https://api.stacceptance.com/activities/search?limit=20"
        
        // [수정 포인트 2] 실제 토큰과 Location ID 입력
        val token = "xxxxxxx"
        val locationId = "xxxx"

        // JSON Body 생성 (가장 안전한 Raw String 방식)
        val mediaType = "application/json; charset=utf-8".toMediaType()
        val jsonBody = """
            {
                "location": "$locationId",
                "include": ["execution"]
            }
        """.trimIndent()
        
        val requestBody = jsonBody.toRequestBody(mediaType)

        // Request 생성 (header()를 사용하여 중복 방지)
        val request = Request.Builder()
            .url(url)
            .post(requestBody)
            .header("Authorization", "Bearer $token")
            .header("Accept", "application/json")
            .header("User-Agent", "curl/7.68.0") // 서버가 curl 요청인 줄 알도록 속임
            .build()

        // 비동기 실행
        client.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                callback("연결 실패: ${e.message}")
            }

            override fun onResponse(call: Call, response: Response) {
                val responseBody = response.body?.string() ?: "응답 없음"
                if (response.isSuccessful) {
                    callback("성공: $responseBody")
                } else {
                    // 여기서 'a resource could not be found' 메시지가 찍힐 것입니다.
                    callback("에러(${response.code}): $responseBody")
                }
            }
        })
    }
}

```

---

### 🔍 테스트 전 최종 체크리스트

1. **Logcat 확인**: 안드로이드 스튜디오 하단 `Logcat` 탭에서 패키지명을 선택하고 `OKHTTP_LOG`를 검색하세요. 요청 헤더와 바디가 curl과 똑같이 나가는지 실시간으로 볼 수 있습니다.
2. **Location ID**: 서버가 "Resource not found"라고 한다면, `locationId` 변수에 들어가는 값이 정말 정확한지(공백 유무 등) 서버 PC의 curl 결과와 대조해 보세요.
3. **네트워크**: 휴대폰이 서버 PC와 같은 Wi-Fi에 연결되어 있는지 확인하세요. 사내망일 경우 방화벽 때문에 폰에서만 안 될 수도 있습니다.

이제 이 코드로 실행해 보시면 헤더 중복 문제는 발생하지 않을 것입니다. 만약 여전히 **404(Resource Not Found)**가 뜬다면, 서버가 요구하는 `location` 형식이 앱에서 보내는 것과 미세하게 다른 것이니 로그캣의 `BODY` 부분을 집중적으로 봐주세요.

성공적으로 데이터가 들어오면 알려주세요! 그 다음 단계인 **폴링(Polling) 로직**으로 전환하는 방법도 바로 도와드릴 수 있습니다.
